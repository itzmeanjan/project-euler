package projecteuler

import "math"

// truncates specified number of digits from left
// side of number
func trucateFromLeft(num int, pos int) int {
	return numFromDigits(splitDigits(num)[pos:], 10)
}

// checks whether all numbers generated by truncating
// left most digit ( one at a time ), are prime or not
func isLeftTruncatablePrime(num int) bool {
	check := true
	for num > 0 {
		if !isPrime(num) {
			check = false
			break
		}
		num = trucateFromLeft(num, 1)
	}
	return check
}

// truncates specified number of digits
// from right side of number
func trucateFromRight(num int, pos int) int {
	return numFromDigits(splitDigits(num)[:int(math.Floor(math.Log10(float64(num))))+1-pos], 10)
}

// checks whether all numbers generated by truncating
// right most digit ( one at a time ), are prime or not
func isRightTruncatablePrime(num int) bool {
	check := true
	for num > 0 {
		if !isPrime(num) {
			check = false
			break
		}
		num = trucateFromRight(num, 1)
	}
	return check
}

// checks whether number is both left and right truncatable or not
func isTruncatablePrime(num int) bool {
	if num < 10 {
		return false
	}
	return isLeftTruncatablePrime(num) && isRightTruncatablePrime(num)
}

// checks whether any digit of given number is `0` or not
func hasDigitZero(num int) bool {
	check := false
	for _, v := range splitDigits(num) {
		if v == 0 {
			check = true
			break
		}
	}
	return check
}

// considering only those numbers which aren't having
// `0` as one of their digit
func isValidNumber(num int) bool {
	return !hasDigitZero(num)
}

// TrunatablePrimes - Calculates sum of first 11 fully truncatable primes
func TrunatablePrimes() int {
	sum := 0
	curN := 10
	for c := 0; c < 11; {
		if isValidNumber(curN) && isTruncatablePrime(curN) {
			sum += curN
			c++
		}
		curN++
	}
	return sum
}
